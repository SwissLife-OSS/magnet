input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

type KeyValuePairOfStringAndString {
  key: String!
  value: String!
}

input KeyValuePairOfStringAndStringFilterInput {
  and: [KeyValuePairOfStringAndStringFilterInput!]
  or: [KeyValuePairOfStringAndStringFilterInput!]
  key: StringOperationFilterInput
  value: StringOperationFilterInput
}

input ListFilterInputTypeOfKeyValuePairOfStringAndStringFilterInput {
  all: KeyValuePairOfStringAndStringFilterInput
  none: KeyValuePairOfStringAndStringFilterInput
  some: KeyValuePairOfStringAndStringFilterInput
  any: Boolean
}

input ListFilterInputTypeOfMessageReceivedLogFilterInput {
  all: MessageReceivedLogFilterInput
  none: MessageReceivedLogFilterInput
  some: MessageReceivedLogFilterInput
  any: Boolean
}

input ListStringOperationFilterInput {
  all: StringOperationFilterInput
  none: StringOperationFilterInput
  some: StringOperationFilterInput
  any: Boolean
}

type MessageReceivedLog {
  receivedAt: DateTime!
  clientName: String
  isMatch: Boolean!
}

input MessageReceivedLogFilterInput {
  and: [MessageReceivedLogFilterInput!]
  or: [MessageReceivedLogFilterInput!]
  receivedAt: DateTimeOperationFilterInput
  clientName: StringOperationFilterInput
  isMatch: BooleanOperationFilterInput
}

type MessageRecord {
  id: ID!
  receivedAt: DateTime!
  type: String!
  from: String!
  body: String
  to: [String]
  primaryReceipient: String!
  receivedLog: [MessageReceivedLog]
  provider: String!
  properties: [KeyValuePairOfStringAndString!]
  title: String!
}

input MessageRecordFilterInput {
  and: [MessageRecordFilterInput!]
  or: [MessageRecordFilterInput!]
  receivedLog: ListFilterInputTypeOfMessageReceivedLogFilterInput
  id: UuidOperationFilterInput
  type: StringOperationFilterInput
  receivedAt: DateTimeOperationFilterInput
  from: StringOperationFilterInput
  to: ListStringOperationFilterInput
  body: StringOperationFilterInput
  properties: ListFilterInputTypeOfKeyValuePairOfStringAndStringFilterInput
  provider: StringOperationFilterInput
}

"""A connection to a list of items."""
type MessagesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MessagesEdge!]

  """A flattened list of the nodes."""
  nodes: [MessageRecord]
}

"""An edge in a connection."""
type MessagesEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: MessageRecord
}

"""Information about pagination in a connection."""
type PageInfo {
  """
  Indicates whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more edges exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Query {
  messages(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: MessageRecordFilterInput
  ): MessagesConnection
  message(id: Uuid!): MessageRecord
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

scalar Uuid

input UuidOperationFilterInput {
  eq: Uuid
  neq: Uuid
  in: [Uuid]
  nin: [Uuid]
  gt: Uuid
  ngt: Uuid
  gte: Uuid
  ngte: Uuid
  lt: Uuid
  nlt: Uuid
  lte: Uuid
  nlte: Uuid
}

